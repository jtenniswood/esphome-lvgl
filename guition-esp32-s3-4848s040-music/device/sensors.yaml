# =============================================================================
# SENSORS - Music dashboard (dynamic media player)
# =============================================================================
# Subscribes to HA trigger-based template sensors that proxy the active media
# player's attributes. The active player is selected via the entity picker
# (addon/entity_picker.yaml) which writes to input_text.esphome_active_player.
#
# See README.md for the required HA template sensor configuration.
# =============================================================================

# Default TV source name (override in your main YAML substitutions if needed)
substitutions:
  tv_source: "TV"

# Store last HA position and time so we can estimate elapsed time between updates
# (HA template sensors poll every 2s; we tick every 1s for smooth progress)
globals:
  - id: last_media_position
    type: float
    initial_value: '0.0'
  - id: last_position_timestamp
    type: int
    initial_value: '0'

# Refresh progress bar and elapsed time every second; when playing, estimate
# position from last HA update + elapsed time so the clock moves smoothly
interval:
  - interval: 1s
    then:
      - if:
          condition:
            lambda: 'return !id(media_source_sensor).has_state() || id(media_source_sensor).state != "${tv_source}";'
          then:
            - lvgl.label.update:
                id: media_elapsed_label
                text: !lambda |-
                  float pos = id(last_position_timestamp) != 0 && id(media_position_sensor).has_state()
                    ? id(media_position_sensor).state : id(last_media_position);
                  if (id(media_player_state_sensor).has_state() && id(media_player_state_sensor).state == "playing") {
                    auto t = id(sntp_time).now();
                    if (t.is_valid() && id(last_position_timestamp) != 0) {
                      pos = id(last_media_position) + (t.timestamp - id(last_position_timestamp));
                      if (pos < 0) pos = 0;
                      float dur = id(media_duration_sensor).has_state() ? id(media_duration_sensor).state : 0.0f;
                      if (dur > 0 && pos > dur) pos = dur;
                    }
                  }
                  char buf[12];
                  int sec = (int)pos;
                  if (sec < 0) sec = 0;
                  int m = sec / 60;
                  int s = sec % 60;
                  snprintf(buf, sizeof(buf), "%02d:%02d", m, s);
                  return std::string(buf);
            - lvgl.bar.update:
                id: media_progress_bar
                value: !lambda |-
                  float pos = id(last_position_timestamp) != 0 && id(media_position_sensor).has_state()
                    ? id(media_position_sensor).state : id(last_media_position);
                  if (id(media_player_state_sensor).has_state() && id(media_player_state_sensor).state == "playing") {
                    auto t = id(sntp_time).now();
                    if (t.is_valid() && id(last_position_timestamp) != 0) {
                      pos = id(last_media_position) + (t.timestamp - id(last_position_timestamp));
                      if (pos < 0) pos = 0;
                      float dur = id(media_duration_sensor).has_state() ? id(media_duration_sensor).state : 0.0f;
                      if (dur > 0 && pos > dur) pos = dur;
                    }
                  }
                  float dur = id(media_duration_sensor).has_state() ? id(media_duration_sensor).state : 0.0f;
                  if (dur > 0) return (int)((pos / dur) * 100.0f);
                  return 0;

# ---------------------------------------------------------------------------
# TEXT SENSORS — subscribe to HA trigger-based template sensors
# ---------------------------------------------------------------------------
text_sensor:
  - platform: homeassistant
    entity_id: sensor.active_media_title
    id: media_title_sensor
    on_value:
      # Track changed — reset position to 0 and stamp the current time so the
      # 1-second interval timer can immediately start counting from 0.
      - lambda: |-
          id(last_media_position) = 0.0f;
          auto t = id(sntp_time).now();
          if (t.is_valid()) {
            id(last_position_timestamp) = t.timestamp;
          }
      - lvgl.label.update:
          id: media_title_label
          text: !lambda 'return x.empty() ? std::string("—") : x;'
      - lvgl.label.update:
          id: media_elapsed_label
          text: "00:00"
      - lvgl.label.update:
          id: media_duration_label
          text: "00:00"
      - lvgl.bar.update:
          id: media_progress_bar
          value: 0

  - platform: homeassistant
    entity_id: sensor.active_media_artist
    id: media_artist_sensor
    on_value:
      - lvgl.label.update:
          id: media_artist_label
          text: !lambda 'return x.empty() ? std::string("—") : x;'

  - platform: homeassistant
    entity_id: sensor.active_entity_picture
    id: media_entity_picture_sensor
    on_value:
      - if:
          condition:
            lambda: 'return !x.empty();'
          then:
            - online_image.set_url:
                id: album_art_background
                url: !lambda |-
                  std::string path = x;
                  while (!path.empty() && (path.back() == '\n' || path.back() == '\r' || path.back() == ' ')) path.pop_back();
                  return std::string("${home_assistant_url}") + path;

  - platform: homeassistant
    entity_id: sensor.active_media_state
    id: media_player_state_sensor
    on_value:
      - if:
          condition:
            lambda: 'return x == "playing";'
          then:
            - lvgl.widget.hide:
                id: media_play_icon
            - lvgl.widget.show:
                id: media_pause_icon
          else:
            - lvgl.widget.show:
                id: media_play_icon
            - lvgl.widget.hide:
                id: media_pause_icon

  - platform: homeassistant
    entity_id: sensor.active_media_source
    id: media_source_sensor
    on_value:
      - if:
          condition:
            lambda: 'return x == "${tv_source}";'
          then:
            # --- Enter TV mode ---
            - lvgl.widget.hide: album_art_background_widget
            - lvgl.widget.hide: media_title_label
            - lvgl.widget.hide: media_artist_label
            - lvgl.widget.hide: media_next_button
            - lvgl.widget.hide: media_previous_button
            - lvgl.widget.hide: media_elapsed_label
            - lvgl.widget.hide: media_duration_label
            - lvgl.widget.hide: media_progress_bar
            - lvgl.widget.show: tv_source_label
          else:
            # --- Exit TV mode (music mode) ---
            - lvgl.widget.show: album_art_background_widget
            - lvgl.widget.show: media_title_label
            - lvgl.widget.show: media_artist_label
            - lvgl.widget.show: media_next_button
            - lvgl.widget.show: media_previous_button
            - lvgl.widget.show: media_elapsed_label
            - lvgl.widget.show: media_duration_label
            - lvgl.widget.show: media_progress_bar
            - lvgl.widget.hide: tv_source_label

# ---------------------------------------------------------------------------
# NUMERIC SENSORS — duration and position from HA template sensors
# ---------------------------------------------------------------------------
sensor:
  - platform: homeassistant
    entity_id: sensor.active_media_duration
    id: media_duration_sensor
    on_value:
      - lvgl.label.update:
          id: media_duration_label
          text: !lambda |-
            char buf[12];
            int sec = (int)x;
            if (sec < 0) sec = 0;
            int m = sec / 60;
            int s = sec % 60;
            snprintf(buf, sizeof(buf), "%02d:%02d", m, s);
            return std::string(buf);

  - platform: homeassistant
    entity_id: sensor.active_media_position
    id: media_position_sensor
    on_value:
      - lambda: |-
          id(last_media_position) = x;
          auto t = id(sntp_time).now();
          if (t.is_valid()) id(last_position_timestamp) = t.timestamp;
      - lvgl.label.update:
          id: media_elapsed_label
          text: !lambda |-
            char buf[12];
            int sec = (int)x;
            if (sec < 0) sec = 0;
            int m = sec / 60;
            int s = sec % 60;
            snprintf(buf, sizeof(buf), "%02d:%02d", m, s);
            return std::string(buf);
      - lvgl.bar.update:
          id: media_progress_bar
          value: !lambda |-
            float pos = x;
            float dur = id(media_duration_sensor).state;
            if (dur > 0) {
              return (int)((pos / dur) * 100.0f);
            }
            return 0;
